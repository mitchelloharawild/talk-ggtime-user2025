---
from: markdown+emoji
execute: 
  cache: true
format: 
  letterbox-revealjs:
    theme: custom.scss
    progress: false
    menu: false
    width: 1280
    height: 720
filters:
  - custom-callouts
callout-appearance: simple
---

## {}

```{r}
#| label: setup
#| include: false

library(fpp3)
options(width = 60)
```

::: columns
::: {.column width="37.5%"}
:::
::: {.column width="60%"}

::: {.title data-id="title"}
Visualizing time with ggtime's grammar of temporal graphics
:::

::: {.dateplace}
9th August 2025 @ useR!, Durham NC
:::

::: authors
Mitchell O'Hara-Wild, Monash University

Cynthia Huang, Monash University

Matthew Kay, Northwestern University

Rob Hyndman, Monash University

:::

::: {.callout-link}

## Useful links

![](resources/forum.svg){.icon} [social.mitchelloharawild.com](https://social.mitchelloharawild.com/)

![](resources/projector-screen-outline.svg){.icon} [slides.mitchelloharawild.com/user2025](https://slides.mitchelloharawild.com/user2025)

![](resources/github.svg){.icon} [mitchelloharawild/talk-ggtime-user2025](https://github.com/mitchelloharawild/talk-ggtime-user2025)

:::

:::
:::

![](backgrounds/estee-janssens-zni0zgb3bkQ-unsplash.jpg){.image-left}

<!-- ## {} -->

<!-- ### Exploratory analysis in the forecasting workflow -->

<!-- ![](resources/workflow.png) -->

<!-- ## {} -->

<!-- ### Exploratory analysis in the forecasting workflow -->

<!-- ![](resources/workflow-etsa.png) -->

## {}

::: columns
::: {.column width="62.5%"}

### Exploring *semantic* variables

Several types of data require unique care.

::: {.incremental}
* :four_leaf_clover: uncertainty
  
  `{distributional}` ðŸ”„ `{ggdist}`

  ... and `{ggdibbler}` ðŸ¤©
* :spider_web: graph 
  
  `{tidygraph}` ðŸ”„ `{ggraph}`
* :world_map: space 
  
  `{sf}` ðŸ”„ `{ggplot2}`
* :hourglass: **time** 
  
  **`{mixtime}` ðŸ”„ `{ggtime}`**
:::


:::
:::

![](backgrounds/david-pisnoy-46juD4zY1XA-unsplash.jpg){.image-right}

## {.fragment-remove}

::: columns
::: {.column width="40%"}
:::
::: {.column width="60%"}

::: {.fragment .fade-out fragment-index=2}
### Exploring temporal data

Time is comparatively simple dimension, it is a *continuous* and *ordered* variable.
:::

:::{.fragment .fade-up fragment-index=1}
::: {.callout-tip}

## ggplot2 already supports temporal data

<!-- Simply map a date (`Date`), datetime (`POSIXct`), or even time (`hms`) to any aesthetic in ggplot2.  -->

Scales in ggplot2 handle temporal labels and breaks:

* `scale_*_date()` for `Date`, 
* `scale_*_datetime()` for `POSIXct`, 
* `scale_*_time()` for `hms`.

Simply map time to any aesthetic in ggplot2.
:::
:::

::: {.fragment .fade-up fragment-index=2}

```{r}
#| label: ggplot-setup
aus_production_tbl <- tsibbledata::aus_production |> 
  as_tibble() |> 
  mutate(Quarter = as.Date(Quarter))
```

```{r}
#| label: ggplot-time
#| echo: true
#| fig-height: 3
library(ggplot2)
aus_production_tbl |>
  ggplot(aes(x = Quarter, y = Beer)) +
  geom_line()
```

:::

:::
:::

![](backgrounds/andrik-langfield-0rTCXZM7Xfo-unsplash.jpg){.image-left}

## {}

::: columns
::: {.column width="40%"}
:::
::: {.column width="60%"}

### So why create ggtime?


::: {.fragment .fade-up}
::: {.callout-note icon=false}
## :calendar: Calendrical time

**Calendrical patterns are complex**! Complexity causes errors!

<!-- Temporal data/patterns align with calendars. -->

<!-- This complexity makes mistakes common. -->

:::{.incremental}

* Calender systems (Gregorian, Islamic, Chinese, Jewish, ...)
* Timezones (local/civil time, absolute time)
* Granularities (hourly, daily, weekly, monthly, annual, ...)
* Corrections (leap years, or even *leap seconds*)
* Seasonality (weekdays/weekends, financial years, holidays)

:::
:::
:::

::: {.fragment .fade-up style="text-align:center;"}
<span>
![](media/tsibble.svg){width="180px"}
![](media/mixtime.svg){width="180px"}
![](media/ggtime.svg){width="180px"}
</span>
:::

<!-- ::: {.callout-important icon=false}
## :alarm_clock: So why do we need ggtime?

`{ggtime}` visualises time with calendrical patterns.

* Visualisation of more calendars and granularities
* Alignment options for timezones, granularities & cycles
* Plotting time cyclically for seasonality & holidays

::: -->

:::
:::

![](backgrounds/andrik-langfield-0rTCXZM7Xfo-unsplash.jpg){.image-left}

## {}

::: columns
::: {.column width="60%"}

### Time series data

Most time series data starts like this:

```{r}
#| label: tibble-ts
#| echo: true
library(tibble)
readr::read_csv("data/tourism.csv")
```

:::
:::


![](backgrounds/henry-be-lc7xcWebECc-unsplash.jpg){.image-right}

## {}

::: columns
::: {.column width="60%"}

### Tidy time series data :broom:

![](media/tsibble.svg){.sticker-float-midright}

A `tsibble` is *tibble* for time series.

```{r}
#| label: tsibble-data
#| echo: true
library(tsibble)
tourism
```

:::
:::


![](backgrounds/henry-be-lc7xcWebECc-unsplash.jpg){.image-right}

## {.fragment-remove}

::: columns
::: {.column width="60%"}

### Mixed temporal vectors

::: {.fragment .fade-out fragment-index=2}

Existing time vectors are limited

* Gregorian calendar only
* Limited granularity options
* Cannot mix temporal granularities

:::

::: {.fragment .fade-up fragment-index=1}

![](media/mixtime.svg){.sticker-float-right .fragment .fade-in fragment-index=1}

::: {.callout-tip}
## A better solution?

The `{mixtime}` package works with:

* Any temporal classes

  <!-- Gregorian, Chinese, Islamic, Hebrew, ... -->
  
* Custom calendars / granularities

  <!-- Business hours, trading days, trimesters, ... -->
  
* Mixed temporal granularities in the same tsibble
  
  <!-- Useful for related series at different frequencies! -->

:::
:::

::: {.fragment .fade-up fragment-index=2}

```{r}
#| label: mixtime-demo
#| echo: true
library(mixtime)
now <- Sys.time()
today <- Sys.Date()
c(
  year(now), yearquarter(now), yearmonth(now), 
  yearweek(now), today, now
)
```
:::

:::
:::

![](backgrounds/jon-tyson-FlHdnPO6dlw-unsplash.jpg){.image-right}


## {.fragment-remove}

::: columns
::: {.column width="60%"}

### Mixed temporal vectors

![](media/calcal.svg){.sticker-float-midright}

::: {.callout-tip}
## Alternative calendars

Non-Gregorian calendars from `{calcal}` also work.
:::


```{r}
#| cache: false
library(calcal)
library(mixtime)
year <- lubridate::year
options(width = 60)
```

```{r}
#| label: calcal-demo
#| echo: true
#| cache: false
library(calcal)
mixtime(
  as_gregorian(today), as_islamic(today), as_hebrew(today),
  as_chinese(today), as_coptic(today), as_mayan(today),
  as_persian(today), as_julian(today), as_egyptian(today)
)
```

:::
:::

![](backgrounds/jon-tyson-FlHdnPO6dlw-unsplash.jpg){.image-right}

## {}

::: columns
::: {.column width="60%"}

### Mixed temporal vectors
![](media/mixtime.svg){.sticker-float-midright}

Temporal aggregation in `tsibble`.

```{r}
#| label: mixtime-echo
#| echo: true
#| eval: false

library(mixtime)
tsibble(
  Time = c(year(2020:2021), yearquarter("2020 Q1") + 0:3, yearmonth("2020 Jan") + 0:11),
  Region = "Melbourne", State = "Victoria", Purpose = "Holiday",
  Trips = ..., # Omitted for brevity
  index = Time, key = c(Region, State, Purpose)
)
```

```{r}
#| label: mixtime
library(mixtime)
tsibble(
  Time = c(mixtime::year(2020:2021), mixtime::yearquarter("2020 Q1") + 0:3, mixtime::yearmonth("2020 Jan") + 0:11),
  Region = "Melbourne",
  State = "Victoria",
  Purpose = "Holiday",
  Trips = c(7783.979, 7542.941, 1880.247, 1965.406, 1928.667, 2009.659, 735.4213106, 573.4142064, 571.4114752, 606.9740834, 747.3060511, 
611.1261341, 662.5029595, 632.0378299, 634.1261913, 581.9617585, 
621.5359481, 806.1614347),
  index = Time, key = c(Region, State, Purpose)
)[c(1,4,2,5,7,9,3,6,8,10:18),]
```

:::
:::

![](backgrounds/jon-tyson-FlHdnPO6dlw-unsplash.jpg){.image-right}

## {}



::: {style="text-align: center;"}
![](media/xkcd-datetime.png){width="800px"}
:::

::: {.fragment .fade-up}
::: {.callout-important}

## Disclaimer: active development

`{mixtime}` and `{ggtime}` require more *time* to mature before general use.
:::
:::

## {}

::: columns
::: {.column width="40%"}
:::
::: {.column width="60%"}

### Extending ggplot2

![](media/ggtime.svg){.sticker-float-right}

Two types of `ggtime` functions:

::: {.callout-note icon=false}
## :framed_picture: Plot helpers

Functions which are used to quickly create a specific plot.

* `autoplot()` / `autolayer()`
* `ggtime::gg_season()`
* `ggtime::gg_subseries()`

:::

::: {.fragment .fade-up}
::: {.callout-tip icon=false}
## :art: Grammar extensions

Functions which add new features to the ggplot2's grammar.

* `ggtime::geom_time_line()`
* `ggtime::scale_x_mixtime()`
* `ggtime::facet_calendar()`

:::
:::


:::
:::

![](backgrounds/estee-janssens-zni0zgb3bkQ-unsplash.jpg){.image-left}

## {}

::: columns
::: {.column width="40%"}
:::
::: {.column width="60%"}

### Extending ggplot2

![](media/ggtime.svg){.sticker-float-right}

Both types serve different needs:

::: {.callout-note icon=false}
## :framed_picture: Plot helpers

Plot helpers focus on **what** is being plotted.

* [Single function **convenient** for data analysis]{.fragment fragment-index=1}
* [**Limited** customisation options]{.fragment fragment-index=2}
* [**Beginner friendly** for users]{.fragment fragment-index=3}

:::

::: {.callout-tip icon=false}
## :art: Grammar extensions

Grammar extensions are about **how** something is plotted.

* [**Composition** of elements for data visualisation]{.fragment fragment-index=1}
* [Very **flexible** usage and styling]{.fragment fragment-index=2}
* [**More complex** to learn and use]{.fragment fragment-index=3}

:::


:::
:::

![](backgrounds/estee-janssens-zni0zgb3bkQ-unsplash.jpg){.image-left}


## {}

::: columns

::: {.column width="40%"}
:::

::: {.column width="60%"}

### Plot helpers for time series

`{ggtime}` has two main types of plot helpers:

* **Linear time plots**

  * `autoplot()`

* **Circular time plots**

  * `gg_season()`
  * `gg_subseries()`

::: {.callout-tip}

## Changing how time is plotted

Linear time plots show time **continuously** on the `x`/`y` axis.

Circular time plots **loop time** over specific calendar units.

:::

:::
:::

![](backgrounds/nathan-dumlao-5Hl5reICevY-unsplash.jpg){.image-left}


<!-- ## {} -->

<!-- ::: columns -->

<!-- ::: {.column width="40%"} -->
<!-- ::: -->

<!-- ::: {.column width="60%"} -->

<!-- ### Linear time plots -->

<!-- These show time as a continuous dimension. -->

<!-- ::: -->
<!-- ::: -->

<!-- ![](backgrounds/nathan-dumlao-5Hl5reICevY-unsplash.jpg){.image-left} -->


## {}

::: columns

::: {.column width="40%"}

### Time plots

Maps time to the x/y-axis.

They reveal trends, seasons, cycles, outliers, and more.


::: {.callout-note icon=false}
## :framed_picture: Plot helper

```r
<tsibble> |>
  autoplot()
```
:::

::: {.fragment .fade-up}
::: {.callout-tip icon=false}
## :art: Grammar elements


* mapping: 
  * **x: time**
  * y: observations
<!-- * coord: cartesian -->

:::
:::

:::

::: {.column width="60%"}

```{r}
#| label: time-plot
#| echo: true
#| fig-height: 8
library(ggtime)
tsibbledata::aus_production |>
  autoplot(Beer)
```

:::

:::

## {}

::: columns

::: {.column width="40%"}

### Forecast plots

![](media/fable.svg){.sticker-float-right}

These are simply time plots.

They just happen to show forecasts, or uncertain values.

::: {.callout-note icon=false}
## :framed_picture: Plot helper

```r
<fable> |> 
  autoplot(<tsibble>)
```
:::

::: {.fragment .fade-up}
![](media/ggdist.svg){.sticker-float-right}

::: {.callout-tip icon=false}
## :art: Grammar elements

* mapping: 
  * x: time
  * y: observations
  * **ydist: forecast** (ggtime :heart: ggdist)
<!-- * coord: cartesian -->

:::
:::

:::

::: {.column width="60%"}

```{r}
#| label: forecast-plot
#| echo: true
#| fig-height: 7
library(fable)
tsibbledata::aus_production |> 
  model(ETS(Beer)) |> 
  forecast() |> 
  autoplot(tsibbledata::aus_production) +
  theme(legend.position = "bottom")
```

:::
:::

<!-- ## {} -->

<!-- ::: columns -->

<!-- ::: {.column width="40%"} -->
<!-- ### Multiple time plots -->

<!-- Most data is long and across many series. -->


<!-- ::: {.callout-tip icon=false} -->
<!-- ## :atom_symbol: Notable grammar elements -->


<!-- * mapping:  -->
<!--   * x: time -->
<!--   * y: observations -->
<!--   * **colour: series** -->
<!-- * **coord: cartesian** -->

<!-- ::: -->

<!-- ::: -->


<!-- ::: {.column width="60%"} -->

<!-- ```{r} -->
<!-- #| label: multitime-plot -->
<!-- #| code-fold: true -->
<!-- #| echo: true -->
<!-- #| fig-height: 8.5 -->
<!-- sugrrants::hourly_peds |>  -->
<!--   filter(Date < as.Date("2016-05-01")) |>  -->
<!--   ggplot(aes(x = Date_Time, y = Hourly_Counts, colour = Sensor_Name)) +  -->
<!--   geom_line() + -->
<!--   theme_bw() + -->
<!--   theme(legend.position = "bottom") -->
<!-- ``` -->

<!-- ::: -->

<!-- ::: -->

<!-- ## {} -->

<!-- ::: columns -->

<!-- ::: {.column width="40%"} -->

<!-- ### Calendar plots -->

<!-- Uses calendar layouts (multiple rows) to partially resolve long series. -->

<!-- ::: {.callout-tip icon=false} -->
<!-- ## :atom_symbol: Notable grammar elements -->


<!-- * mapping:  -->
<!--   * x: time -->
<!--   * y: observations -->
<!--   * colour: series -->
<!-- * coord: cartesian -->
<!-- * **facet: calendar** -->

<!-- ::: -->


<!-- ::: -->

<!-- ::: {.column width="60%"} -->

<!-- ```{r} -->
<!-- #| label: facet-calendar -->
<!-- #| code-fold: true -->
<!-- #| echo: true -->
<!-- #| fig-height: 8.5 -->
<!-- library(sugrrants) -->
<!-- hourly_peds %>% -->
<!--   filter(Date < as.Date("2016-05-01")) %>%  -->
<!--   ggplot(aes(x = Time, y = Hourly_Counts, colour = Sensor_Name)) + -->
<!--   geom_line() + -->
<!--   facet_calendar(~ Date) + # a variable contains dates -->
<!--   theme_bw() + -->
<!--   theme(legend.position = "bottom") -->
<!-- ``` -->

<!-- ::: -->

<!-- ::: -->


<!-- ## {} -->

<!-- ::: columns -->

<!-- ::: {.column width="40%"} -->
<!-- ::: -->

<!-- ::: {.column width="60%"} -->

<!-- ### Circular time plots -->

<!-- Transforms time to reveal circular patterns. -->

<!-- ::: -->
<!-- ::: -->

<!-- ![](backgrounds/nathan-dumlao-5Hl5reICevY-unsplash.jpg){.image-left} -->


## {}

::: columns

::: {.column width="40%"}

### Seasonal plots

Loops seasons to align years.


::: {.callout-note icon=false}
## :framed_picture: Plot helper

```r
<tsibble> |>
  gg_season(period = "year")
```
:::

::: {.fragment .fade-up}
::: {.callout-tip icon=false}
## :art: Grammar elements

* mapping: 
  * **x: season** (e.g. `hms`)
  * y: observations
  * colour: time
<!-- * coord: cartesian -->

:::
:::

:::

::: {.column width="60%"}

```{r}
#| label: season-plot
#| echo: true
#| fig-height: 7
tsibbledata::aus_production |>
  gg_season(Beer, period = "year")
```

:::

:::

<!-- ## {} -->

<!-- ::: columns -->

<!-- ::: {.column width="40%"} -->

<!-- ### Seasonal plots -->

<!-- They are often shown in polar. -->

<!-- ::: {.callout-tip icon=false} -->
<!-- ## :atom_symbol: Notable grammar elements -->


<!-- * mapping:  -->
<!--   * x: season -->
<!--   * y: observations -->
<!--   * colour: time -->
<!-- * **coord: polar** -->

<!-- ::: -->

<!-- ::: -->

<!-- ::: {.column width="60%"} -->

<!-- ```{r} -->
<!-- #| code-fold: true -->
<!-- #| echo: true -->
<!-- #| fig-height: 8.5 -->
<!-- pbs_scripts |> -->
<!--   gg_season(Scripts, polar = TRUE) -->
<!-- ``` -->

<!-- ::: -->

<!-- ::: -->

## {}

::: columns

::: {.column width="40%"}

### Seasonal sub-series

Seasonal facets shows changes in seasons.


::: {.callout-note icon=false}
## :framed_picture: Plot helper

```r
<tsibble> |>
  gg_subseries(period = "year")
```
:::

::: {.fragment .fade-up}
::: {.callout-tip icon=false}
## :art: Grammar elements

* mapping: 
  * x: time
  * y: observations
<!-- * coord: cartesian -->
* **facet: season**

:::
:::


:::

::: {.column width="60%"}

```{r}
#| label: subseries-plot
#| echo: true
#| fig-height: 7
tsibbledata::aus_production |>
  gg_subseries(Beer, period = "year")
```

:::

:::



## {}

::: columns

::: {.column width="40%"}

### Seasonal sub-series

![](media/feasts.svg){.sticker-float-right}

Remove the trend to clearly see seasonal changes.


::: {.callout-note icon=false}
## :framed_picture: Plot helper

```r
<dcmp> |>
  gg_subseries(period = "year")
```
:::

::: {.callout-tip icon=false}
## :art: Grammar elements

* mapping: 
  * x: time
  * y: observations
<!-- * coord: cartesian -->
* **facet: season**

:::


:::

::: {.column width="60%"}

```{r}
#| label: dcmp-subseries-plot
#| echo: true
#| fig-height: 7
tsibbledata::aus_production |>
  model(STL(Beer)) |>
  components() |>
  gg_subseries(season_year, period = "year")
```

:::

:::

## {}

::: columns

::: {.column width="40%"}
:::

::: {.column width="60%"}

### Grammar extensions

`{ggtime}` decomposes these plot helpers into grammatical elements for `{ggplot2}`.

::: {.callout-tip}

## Composable grammars

* Combine elements to create new plots.
* Customise the style and structure.
* Works well with other ggplot extensions.

:::

:::
:::

![](backgrounds/nathan-dumlao-5Hl5reICevY-unsplash.jpg){.image-left}


## {.fragment-remove .dense-list}

```{css}
.dense-list ul, .dense-list details {
  margin-bottom: 0 !important;
}
```

::: columns

::: {.column width="60%"}

### Geometries

* `geom_time_line()`

  ::: {.fragment .fade-out fragment-index=2}
  A time-aware version of `geom_line()`. Shows timezone offsets with dashed lines from the `[x/y]_time_offset` **aesthetic**.
  
  ```{r}
  #| code-fold: true
  #| echo: true
  
  tz_shift <- as_tibble(tsibbledata::gafa_stock) |>
    filter(
      (Symbol == "AAPL" & Date <= "2014-01-15") | 
        (Symbol == "GOOG" & Date <= "2014-01-13")
    ) |>
    mutate(Date = Sys.Date() + hours(c(1:3, 3:9, 1:2, 4:9)), DST = ifelse(Symbol == "AAPL", "DST Ends", "DST Begins")) |> 
    slice(1:3, 3:12, 12:n()) |> 
    mutate(
      open = duplicated(Open),
      closed = c(open[-1], FALSE),
      Date = Date + open*3600*((DST=="DST Begins")*2-1)
    ) 
  
  tz_shift |> 
    ggplot(aes(x = Date, y = Close)) + 
    geom_path(aes(group = cumsum(open))) + 
    geom_path(linetype = "dashed", data = filter(tz_shift, open | closed)) +
    facet_wrap(vars(DST), ncol = 2, scales = "free_y") + 
    scale_shape_manual(values = c("TRUE" = 16, "FALSE" = 1)) + 
    guides(shape = "none")
  ```
  
  :::


::: {.fragment .fade-up fragment-index=2}
* `geom_time_candle()`

  Shows value changes over time periods (e.g. daily, weekly, ...) which are calculated using the `stat_candle` **statistic**.
  
```{r}
#| code-fold: true
#| echo: true
#| fig-height: 3.5
tsibbledata::gafa_stock |> 
  filter(Symbol == "GOOG") |> 
  filter(yearmonth(Date) == yearmonth("2014 Jun")) |> 
  ggplot(aes(x = Date)) + 
  tidyquant::geom_candlestick(
    aes(open = Open, high = High, low = Low, close = Close),
    colour_up = "#1FB974", fill_up = "#1FB974", colour_down = "#F4375D", fill_down = "#F4375D"
  ) + 
  scale_x_date(date_labels = "%d %b %Y") +
  labs(y = "GOOG Stock")
```
:::


:::
:::

![](backgrounds/gglayers-1528209746.png){.image-right}

## {.fragment-remove}

::: columns

::: {.column width="60%"}

### Positions

The x/y position of time is timezone adjusted:

* `position_time_absolute()` positions time at its exact global location.

  ::: {.fragment .fade-out fragment-index=1}
  ```{r}
  #| code-fold: true
  #| echo: true
  #| fig-height: 3.5
  pedestrian |> 
    filter(Sensor == "Southern Cross Station") |> 
    filter(year(Date_Time) == 2015) |> 
    mutate(Date_Time = force_tz(make_datetime(year(Date), month(Date), day(Date), Time), "Australia/Melbourne")) |> 
    ggplot(aes(x = Date_Time - as.POSIXct(Date), y = Count, group = Date)) + 
    geom_line(alpha = 0.2) + 
    theme(axis.text.x = element_blank()) + 
    labs(x = "Time", title = "Hourly pedestrians passing Southern Cross Station")
  ```

  Timezone differences (e.g. daylight savings) misaligns seasonal patterns.
  :::

::: {.fragment .fade-up fragment-index=1}
* `position_time_civil()` positions time as it appears locally in each timezone.


  ```{r}
  #| code-fold: true
  #| echo: true
  #| fig-height: 3.5
  pedestrian |> 
    filter(Sensor == "Southern Cross Station") |> 
    filter(year(Date_Time) == 2015) |> 
    ggplot(aes(x = Time, y = Count, group = Date)) + 
    geom_line(alpha = 0.2) + 
    theme(axis.text.x = element_blank()) + 
    labs(x = "Time", title = "Hourly pedestrians passing Southern Cross Station")
  ```

:::
<!-- TODO: Add example from pedestrian counters -->

:::
:::

![](backgrounds/gglayers-1528209746.png){.image-right}


## {}

::: columns

::: {.column width="60%"}

### Scales

:::{style="font-size:80%;"}
The scales in `ggplot2` provide:

* `scale_*_date()` for `Date`, 
* `scale_*_datetime()` for `POSIXct`, 
* `scale_*_time()` for `hms`.

Extension packages (e.g. `tsibble`) add:

* `scale_*_yearquarter()` for `yearquarter`,
* `scale_*_yearmonth()` for `yearmonth`, 
* `scale_*_yearweek()` for `yearweek`.
:::

::: {.fragment .fade-up}
::: callout-tip

## Unified scales for time series

`mixtime` has many calendars and granularities.

`ggtime` unifies them all with `scale_*_mixtime()`.

:::
:::

:::
:::

![](backgrounds/gglayers-1528209746.png){.image-right}


## {}

::: columns

::: {.column width="60%"}

### Scales

The mixtime scales support temporal labels and breaks, much like ggplot2:

* `time_labels` (strftime, e.g. `"%Y %b"`)
* `time_breaks` (duration, e.g. `"3 months"`)

::: {.fragment .fade-up}

These scales also have alignment options:

* `time_align` (numeric, 0-1)
* `time_warp` (duration, e.g. `"1 month"`)
  `warp` (times, e.g. `2025-01-28`)

:::

:::
:::

![](backgrounds/gglayers-1528209746.png){.image-right}


## {.fragment-remove}

::: columns

::: {.column width="40%"}
:::
::: {.column width="60%"}

### Granularity alignment

::: {.fragment .fade-out fragment-index=1}
`{ggtime}` **aligns mixed granularities**.

Imagine Australian births (annual) compared with total births by state (monthly).
:::

```{r}
recent_births <- aus_births |> 
  filter(Month >= yearmonth("2016 Jan"))

aus_total_births <- recent_births |> 
  index_by(year = year(Month)) |> 
  summarise(Births = sum(Births))

recent_births |>
  summarise(Births = sum(Births)) |> 
  ggplot(aes(x = Month, y = Births)) + 
  geom_line() + 
  geom_line(aes(x = make_date(year = year), y = Births / 12), data = aus_total_births, colour = "steelblue", linewidth = 1.5) +
  geom_point(aes(x = make_date(year = year), y = Births / 12), data = aus_total_births, colour = "darkblue", size = 5)
```

::: {.fragment .fade-up fragment-index=1}
::: {.callout-note icon=false}

## :date: Temporal alignment across granularities

When constrained to Date and POSIXct, left alignment is commonly used for less-frequent granularities.

e.g. `2025-01-01` can be 2025, Jan 2025, or Jan 1 2025.

Consequently, plotting is also often left-aligned.
:::
:::

:::
:::

![](backgrounds/chris-lee-70l1tDAI6rM-unsplash.jpg){.image-left}


## {.fragment-remove}

::: columns

::: {.column width="40%"}
:::
::: {.column width="60%"}

### Granularity alignment

`{ggtime}` center aligns granularities.

```{r}
recent_births <- aus_births |> 
  filter(Month >= yearmonth("2016 Jan"))

aus_total_births <- recent_births |> 
  index_by(year = year(Month)) |> 
  summarise(Births = sum(Births))

recent_births |>
  summarise(Births = sum(Births)) |> 
  ggplot(aes(x = Month, y = Births)) + 
  geom_line() + 
  geom_line(aes(x = make_date(year = year, month = 6), y = Births / 12), data = aus_total_births, colour = "forestgreen", linewidth = 1.5) +
  geom_point(aes(x = make_date(year = year, month = 6), y = Births / 12), data = aus_total_births, colour = "darkgreen", size = 5)
```

::: {.callout-note icon=false}

## :date: Aligning temporal granularities

Specify alignment of different granularities with `scale_x_mixtime(align_time = <0-1>)`.
:::

:::
:::

![](backgrounds/chris-lee-70l1tDAI6rM-unsplash.jpg){.image-left}


## {.fragment-remove}

::: columns

::: {.column width="40%"}
:::
::: {.column width="60%"}

### Time warping

`{ggtime}` defaults to center alignment.

::: {.fragment .fade-out fragment-index=1}

Cycles are repeating patterns with an irregular duration (and shape).

```{r}
#| fig-height: 6.5
month_progress <- unlist(lapply(lubridate:::N_DAYS_IN_MONTHS, \(x) seq(1, x)/x))

time <- make_date(year = 2025) + 0:364
# y <- rnorm(length(month_progress), mean = month_progress^4, sd = month_progress*0.1)
y <- sin(month_progress*2*pi) + rnorm(365, sd = 0.1)


tbl_ragged <- tibble(time, y, month_progress)
tbl_ragged |> 
  ggplot(aes(x = time - floor_date(time, "month"), y = y, group = month(time))) + 
  geom_line() +
  geom_point(
    data = tbl_ragged |> group_by(yearmonth(time)) |> filter(time %in% range(time)),
    size = 3
  ) + 
  facet_grid(rows = vars(month(time, label = TRUE))) + 
  labs(x = "Day of month")

```
:::

::: {.fragment .fade-up fragment-index=1}

Warping cycles to have the same length as "% of cycle" can help **compare cycle shapes**.

::: {.fragment .fade-out fragment-index=2}
```{r}
#| fig-height: 6.5
month_progress <- unlist(lapply(lubridate:::N_DAYS_IN_MONTHS, \(x) seq(1, x)/x))

time <- make_date(year = 2025) + 0:364
# y <- rnorm(length(month_progress), mean = month_progress^4, sd = month_progress*0.1)
y <- sin(month_progress*2*pi) + rnorm(365, sd = 0.1)

tbl_justified <- tibble(time, y, month_progress)
tbl_justified |> 
  ggplot(aes(x = month_progress, y = y, group = month(time))) + 
  scale_x_continuous(labels = scales::percent) +
  geom_line() +
  geom_point(
    data = tbl_justified|> group_by(yearmonth(time)) |> filter(time %in% range(time)), 
    size = 3
  ) +
  facet_grid(rows = vars(month(time, label = TRUE))) + 
  labs(x = "Percentage of month")
```
:::
:::

::: {.fragment .fade-up fragment-index=2}

::: {.callout-note icon=false}

## :date: Temporal alignment across cycles

In `scale_x_mixtime()`, warp time with

* `warp` (stretch time between specific time points)
* `time_warp` (stretch time by duration, e.g. `"1 month"`)

:::
:::

:::
:::

![](backgrounds/chris-lee-70l1tDAI6rM-unsplash.jpg){.image-left}


## {}

::: columns

::: {.column width="60%"}

### Facets & Coordinates

Two calendar-plot approaches:

* `facet_calendar()`
* `coord_calendar()`

:::{.callout-tip icon=false}
## :date: Calendar layouts for temporal graphics

Calendars are useful for plotting long time series, they:

* use a familiar layout for quickly identifying dates.
* reveal short annual patterns (e.g. holidays and events).
* have a better aspect-ratio for dense time axis. 
* more effectively use vertical space.

Calendars are not limited to the standard weekly layout, but are hierarchical in nature over any calendar structure.
:::

:::
:::

![](backgrounds/gglayers-1528209746.png){.image-right}


## {}

::: columns

::: {.column width="60%"}

### Calendar facets

[Facets separate each day (or calendar period).]{style="font-size:80%"}

```{r}
#| fig-height: 8.5
library(sugrrants)
hourly_peds %>%
  filter(Date < as.Date("2016-05-01")) %>% 
  ggplot(aes(x = Time, y = Hourly_Counts, colour = Sensor_Name)) +
  geom_line() +
  facet_calendar(~ Date) + # a variable contains dates
  theme_bw() +
  theme(legend.position = "bottom")
```

:::
:::

![](backgrounds/gglayers-1528209746.png){.image-right}


## {}

::: columns

::: {.column width="60%"}

### Calendar coordinates

[Each day (or calendar period) shares the same panel.]{style="font-size:80%"}

```{r}
#| fig-height: 8.5
library(sugrrants)
(hourly_peds %>%
  filter(Date < as.Date("2016-05-01"), Sensor_ID == 9) %>% 
  frame_calendar(x = Time, y = Hourly_Counts, date = Date) %>% 
  ggplot(aes(x = .Time, y = .Hourly_Counts, group = Date)) +
  geom_path() +
  theme(legend.position = "bottom")) |> 
  prettify()
```

:::
:::

![](backgrounds/gglayers-1528209746.png){.image-right}

## {}

::: columns

::: {.column width="60%"}

### Facets & Coordinates

Season plots loop time over seasonalities.

* `coord_time_loop()`

The time loop points can be specified with:

* `loops` (loop over specific time points)
* `time_loops` (loop by duration - `"1 week"`)

:::
:::

![](backgrounds/gglayers-1528209746.png){.image-right}


## {.fragment-remove}

::: columns

::: {.column width="60%"}

### Looping circular time periods


```{r}
#| label: loop-timeplot
tsibbledata::aus_production |>
  autoplot(Beer)
```

:::
:::

![](backgrounds/gglayers-1528209746.png){.image-right}

## {.fragment-remove}

::: columns

::: {.column width="60%"}

### Looping circular time periods


```{r}
#| label: loop-vline
tsibbledata::aus_production |>
  autoplot(Beer) + 
  geom_vline(xintercept = as.Date(tsibble::yearquarter("1956 Q1")), colour = "orange") +
  geom_vline(xintercept = as.Date(tsibble::yearquarter("1956 Q1") + (1:54)*4), colour = "deepskyblue") + 
  geom_line()
```

:::{.callout-tip}
## Looping continuous time

Looping the x-axis over seasonal granularities (e.g. day, week, or year) clearly shows seasonality.

`coord_time_loop(time_loops = "1 year")`

:::

:::
:::

![](backgrounds/gglayers-1528209746.png){.image-right}

## {.fragment-remove}

::: columns

::: {.column width="60%"}

### Looping circular time periods


```{r}
#| loop: loop-season
tsibbledata::aus_production |>
  gg_season(Beer)
```

:::{.callout-tip}
## Looping continuous time

Looping the x-axis over seasonal granularities (e.g. day, week, or year) clearly shows seasonality.

`coord_time_loop(time_loops = "1 year")`

:::

:::
:::

![](backgrounds/gglayers-1528209746.png){.image-right}


## {.fragment-remove}

::: columns

::: {.column width="60%"}

### Looping circular time periods

```{r}
tsibbledata::aus_production |>
  gg_season(Beer, polar = TRUE)
```

:::{.callout-tip}
## Non-cartesian coordinates

Looping conceptually applies to other coordinate spaces too. Combining `coord_loop()` and `coord_polar()` shows seasonality in polar coordinates.
:::

:::
:::

![](backgrounds/gglayers-1528209746.png){.image-right}




## Thanks for your time!

::: columns
::: {.column width="60%"}

::: {.callout-tip}
## Closing remarks 

* Stay tuned! Follow the progress on GitHub.
* Combine semantic variables together with tibble.

  ```r
  tibble(
    time = <mixtime>,
    geometry = <sf>,
    prediction = <distributional>
  )
  ```

:::

::: {.callout-link}

## Useful links

![](resources/forum.svg){.icon} [social.mitchelloharawild.com](https://social.mitchelloharawild.com/)

![](resources/projector-screen-outline.svg){.icon} [slides.mitchelloharawild.com/user2025](https://slides.mitchelloharawild.com/user2025)

![](resources/github.svg){.icon} [mitchelloharawild/talk-ggtime-user2025](https://github.com/mitchelloharawild/talk-ggtime-user2025)
:::

:::
:::

![](backgrounds/meric-dagli-7NBO76G5JsE-unsplash.jpg){.image-right}

## Unsplash credits

::: {.callout-unsplash}

## Thanks to these Unsplash contributors for their photos

```{r unsplash}
#| echo: FALSE
#| cache: TRUE
library(httr)
library(purrr)
unsplash_pattern <- ".*-(.{11})-unsplash\\.jpg.*"
slides <- readLines("index.qmd")
backgrounds <- slides[grepl("backgrounds/.+?unsplash.jpg", slides)]
images <- unique(sub(".*\\(backgrounds/(.+?)\\).*", "\\1", backgrounds))
images <- images[grepl(unsplash_pattern, images)]
ids <- sub(unsplash_pattern, "\\1", images)

get_unsplash_credit <- function(id) {
  unsplash_url <- "https://api.unsplash.com/" 
  my_response <- httr::GET(unsplash_url, path = c("photos", id), query = list(client_id=Sys.getenv("UNSPLASH_ACCESS")))
  xml <- content(my_response)
  
  name <- xml$user$name
  desc <- xml$description%||%"Photo"
  sprintf(
    "* %s: [%s%s](%s)",
    name,
    strtrim(desc,pmax(1, 60-nchar(name))),
    if(nchar(desc)>(60-nchar(name))) "..." else "",
    modify_url("https://unsplash.com/", path = file.path("photos", xml$id))
  )
}
htmltools::includeMarkdown(paste0(map_chr(ids, get_unsplash_credit), collapse = "\n"))
```

:::
